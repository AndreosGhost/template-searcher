package phoenix.templatesearcher.test;

import static phoenix.templatesearcher.support.Utility.*;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import junit.framework.AssertionFailedError;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;

import phoenix.templatesearcher.api.IMetaTemplateMatcher;
import phoenix.templatesearcher.api.IOccurence;
import phoenix.templatesearcher.support.Occurence;
import phoenix.templatesearcher.support.ReadOnlyPair;
import phoenix.templatesearcher.test.support.StringCharStream;

/**
 * This is a basic class for all tests on implementations of
 * {@link IMetaTemplateMatcher}. Each extention of this class should provide the
 * following method:<br/>
 * {@code public static Collection<Object[]> data() } as described in
 * {@link Parameterized} runner.
 * 
 * @author phoenix
 * 
 * @param <MatcherType>
 *            concrete class that is tested
 * @see Parameterized
 */
@Ignore
@RunWith(Parameterized.class)
public abstract class BasicTest<MatcherType extends IMetaTemplateMatcher> {
    /**
     * This method should return a new instance of {@code MatcherType}.
     * 
     * @return
     */
    protected abstract MatcherType obtainFreshMatcher();

    /**
     * Generates a random test according to given parameter boundaries
     * 
     * @param templatesMinCount
     *            minimal count of templates
     * @param templatesMaxCount
     *            maximal count of templates
     * @param minTemplateLength
     *            minimal length of each template
     * @param maxTemplateLength
     *            maximal length of each template
     * @param minStreamLength
     *            minimal length of the stream
     * @param maxStreamLength
     *            maximal length of the stream
     * @return a pair (stream, templates[])
     */
    public static ReadOnlyPair<String, String[]> makeTestData(
	    int templatesMinCount, int templatesMaxCount,
	    int minTemplateLength, int maxTemplateLength, int minStreamLength,
	    int maxStreamLength) {
	String stream = randomString(randomInt(minStreamLength, maxStreamLength));
	int templatesCount = randomInt(templatesMinCount, templatesMaxCount);

	String[] templates = new String[templatesCount];

	for (int i = 0; i < templatesCount; i++) {
	    templates[i] = randomString(randomInt(minTemplateLength,
		    maxTemplateLength));
	}

	return new ReadOnlyPair<String, String[]>(stream, templates);
    }

    @Parameter(value = 0)
    public String stream;

    @Parameter(value = 1)
    public String[] templates;

    /**
     * This method is invoked by test runner and calls
     * {@code testMatchStream(stream, templates) }.
     */
    @Test
    public void testMatchStream() {
	testMatchStream(stream, templates);
    }

    /**
     * Performs a single test with given parameters.
     * 
     * @param stream
     * @param templates
     */
    public void testMatchStream(String stream, String[] templates) {
	MatcherType matcher = obtainFreshMatcher();

	for (int i = 0, len = templates.length; i < len; i++) {
	    matcher.addTemplate(templates[i]);
	}

	List<IOccurence> actualResults = matcher
		.matchStream(new StringCharStream(stream));
	List<IOccurence> expectedResulsts = matchStreamVeryNaive(stream,
		templates);

	try {
	    checkOccurenceResults(actualResults, expectedResulsts);
	} catch (AssertionFailedError ass) {
	    System.err.println("Failure: " + ass.getMessage());
	    System.err.println("Stream: " + stream);
	    System.err.println("Templates: " + Arrays.toString(templates));
	    throw ass;
	}
    }

    /**
     * Finds matches in the stream using {@link String } methods.
     * 
     * @param stream
     * @param templates
     * @return
     */
    public static List<IOccurence> matchStreamVeryNaive(String stream,
	    String[] templates) {
	List<IOccurence> results = new LinkedList<IOccurence>();

	for (int templID = 0, templCount = templates.length; templID < templCount; templID++) {
	    String template = templates[templID];

	    int index = 0;

	    while (true) {
		index = stream.indexOf(template, index);
		if (index >= 0) {
		    results.add(new Occurence(index + template.length() - 1,
			    templID));
		    index++;
		} else {
		    break;
		}
	    }
	}

	return results;
    }

    /**
     * Checks whether two result sets are equal. If not, an
     * {@link AssertionFailedError } is thrown.
     * 
     * @param actual
     *            result set generated by the tested class
     * @param expected
     *            result set generated by our very naive method.
     * @throws AssertionFailedError if result sets are not equal (order is ignored)
     */
    public static void checkOccurenceResults(List<IOccurence> actual,
	    List<IOccurence> expected) throws AssertionFailedError {
	HashSet<IOccurence> checkSet = new HashSet<IOccurence>();

	checkSet.addAll(actual);

	for (IOccurence occ : expected) {
	    boolean removed = checkSet.remove(occ);
	    if (!removed) {
		// not present
		throw new AssertionFailedError(
			String.format(
				"Expected element not present: %s;\nExpected set: %s;\nActual set: %s",
				occ, expected, actual));
	    }
	}

	if (!checkSet.isEmpty()) {
	    throw new AssertionFailedError(
		    String.format(
			    "Extra elements found: %s;\nExpected set: %s;\nActual set: %s",
			    checkSet, expected, actual));
	}
    }

    /**
     * Parameters are wrapped into array ready to be given to {@link Parameterized } runner.
     * @param pair a pair (stream, templates[]).
     * @return an array { stream, templates[] }.
     */
    protected static Object[] wrapParameters(ReadOnlyPair<String, String[]> pair) {
	return new Object[] { pair.getKey(), pair.getValue() };
    }
}
